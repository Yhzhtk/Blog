---
layout: post
title: 一句话总结设计模式
description: 复习了一下设计模式，用一句话总结一下，希望能加深记忆，在使用中不断理解。
tags: [设计模式]
---

<p>复习了一下设计模式，发现有些没用过，没理解，还是不熟悉，翻看一遍，用一句话总结一下，希望能加深记忆，在使用中不断理解。</p>
<h3>设计模式三个大类：</h3>
<ol>
<li>创造型设计模式：创造，就是产生一个新对象。</li>
<li>结构型设计模式：结构，注重设计架构，一些可直接参考的结构体系，可理解为整体模型。</li>
<li>行为型设计模式：行为，是动态的，注重调用、改变等动作。</li>
</ol>
<!--break-->
<h3><strong>创造型设计模式：</strong></h3>
<ol>
<li>单例模式：只能有唯一一个实例，不能外部new对象。</li>
<li>工厂模式：用于根据需求生产对象，生产的过程有工厂完成，不需要外部new。</li>
<li>抽象工厂模式：工厂的工厂，根据需求生产工厂，多层抽象。</li>
<li>生成器模式：生产一个对象需要多个步骤，用生成器模式封装这个步骤流程。</li>
<li>原型模式：存在一个原始对象，现需要一个新对象，新对象仅有少量属性与原始对象不同，那么就拷贝原始对象后，仅修改不同的属性；这样就只设置很少的不同地方，而不需要重新设置很多个相同的地方。（好吧，表达能力不好）</li>
</ol>
<h3><strong>结构性设计模式：</strong></h3>
<ol>
<li>适配器模式：已有一个老方法实现了某个功能，现在外部需要使用这个功能，但是调用接口却和老方法不一致，那么就新建一个方法，适配调用接口，里面再调用老方法的功能就行了。</li>
<li>桥接模式：搭建一个桥通道，连接双方，无论各自内容和方法怎么变化，双方只要都连接到桥上，通过桥都可以相互调用了。</li>
<li>组合模式：基于层次结构，整体和部分的概念，调用外部整体后，整体循环调用内部所有部分。</li>
<li>装饰器模式：一个模块中，有一个小的特点，但是却有N多种形式，那么可以把这个小特点做成一个装饰，将装饰附加到原来的模块中，而不需要在原来模块中加这个特点。（强调小而多，所以算作装饰）</li>
<li>外观模式：也叫”门面模式”，将内部复杂的处理步骤封装一下，对外提供一个友好的接口。</li>
<li>享元模式：对象共享，多个地方使用相同功能或数据时，共享一个对象就行了，不必每次使用都创建一个。</li>
<li>代理模式：对外提供代理，不想让被直接暴露在外，或者被直接访问，一对一的代理。</li>
<li>MVC模式：Model – View – Controller 这个就不细说了。</li>
</ol>
<h3><strong>行为型设计模式：</strong></h3>
<ol>
<li>观察者模式：订阅-发布，维护一个订阅列表，每次发一个消息时，循环发送列表每一个订阅者。（事件监听器就是这种模式）</li>
<li>状态模式：是对象的行为模式，对象的状态是和行为关联的，状态改变后，对应的行为也会发生变化。即状态决定行为。</li>
<li>策略模式：解决问题时，根据不同的条件，使用不同的策略。</li>
<li>模板模式：对相同的步骤建立一个模板流程，允许子类修改特定的步骤，但不影响整个模板流程。</li>
<li>访问者模式：结构对象有多个元素，一次访问结果对象时，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。</li>
<li>职责链模式：一个请求 传递给<span style="color: #333333;">一个节点链处理，每个节点可以接受这个处理，或者传递给下一个，直到被处理掉。所有的操作都是按照规定的链条进行的。客户端并不知道具体哪个节点处理这个请求。</span></li>
<li>命令模式：将所有的操作和参数封装到一个命令对象中，以传递命令对象，接受命令对象并处理的方式工作。</li>
<li>解释器模式：定义一个文法和一个解释器，给定符合文法的输入，解释器解析后便知道结果，如正则表达式。</li>
<li>迭代器模式：迭代操作，判断是否有下一个，如果有下一个则继续处理，知道完成所有。</li>
<li>中介模式：多个同事合作时，可以将多对多的网状合作关系由中介者来管理，变成了星状关系。</li>
<li>备忘录模式：记录某个时间的状态，存档保存，在未来某个时间可以回滚到备忘的某个状态。</li>
</ol>
<p>&nbsp;</p>
